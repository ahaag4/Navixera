// Smart Vehicle Tracker - Patched (Mobizt FirebaseESP8266)
// Libraries required:
//   - FirebaseESP8266 (Mobizt)
//   - TinyGPSPlus
//   - SoftwareSerial
//   - FS (SPIFFS)
// Upload with Arduino IDE (ESP8266 board) and the libraries installed.

#include <ESP8266WiFi.h>
#include <FirebaseESP8266.h>   // Mobizt Firebase client
#include <SoftwareSerial.h>
#include <TinyGPS++.h>
#include <FS.h>
#include <time.h>

// ===== CONFIG =====
#define WIFI_SSID     "sarth"
#define WIFI_PASSWORD "123456789"

// Firebase Realtime DB host (no https://)
#define FIREBASE_HOST "svms-c0232-default-rtdb.firebaseio.com"

// Use Web API key (safer than legacy DB secret for client use)
#define FIREBASE_AUTH "c5430c9db5f61407075f3406b937fe8df9e751c9"

// DB user node (must match dashboard)
#define USER_ID "hFcielg1J6SLceVwYynrCZosfPp2"

// ===== HW PINS =====
#define GPS_RX D5
#define GPS_TX D6
#define MOTION_SENSOR D7
#define BUZZER D8
#define BATTERY_PIN A0

// ===== TIMING CONFIG =====
#define LOOP_DELAY_MS        2000UL   // main loop delay
#define STATUS_UPDATE_MS    10000UL   // how often to write /current & /components
#define HISTORY_PUSH_MS     30000UL   // minimum interval between history pushes
#define STOPPED_THRESHOLD   15000UL   // consider stopped after this (ms)
#define TRIGGER_COOLDOWN    60000UL   // cooldown between triggers (ms)
#define ONLINE_TTL_MS       90000UL   // consider offline if no heartbeat within this
#define HEARTBEAT_RATE_MS   (ONLINE_TTL_MS / 3) // how often to refresh heartbeat
#define MOTION_STABLE_MS      300UL   // require motion stable for this before detect

// ===== GLOBALS =====
SoftwareSerial gpsSerial(GPS_RX, GPS_TX);
TinyGPSPlus gps;

double latitude = 0.0, longitude = 0.0;
String alarmState = "off";
unsigned long lastLocationUpdate = 0;
unsigned long lastMotion = 0;
unsigned long lastTriggerTime = 0;
bool motionDetected = false;
unsigned long lastHeartbeat = 0;
bool lastOnlineState = false;

unsigned long lastStatusWrite = 0;
unsigned long lastHistoryPush = 0;
unsigned long motionRiseTime = 0;

// Firebase (Mobizt new style)
FirebaseConfig config;
FirebaseAuth auth;
FirebaseData fbdo;

// SPIFFS flag
bool spiFFSmounted = false;

// forward
void setOnlineFlag(bool on);

// ===== SETUP =====
void setup() {
  Serial.begin(115200);
  delay(100);

  // seed random with a floating analog read if available (for battery fallback)
  randomSeed(analogRead(A0) ^ ESP.getChipId());

  gpsSerial.begin(9600);
  pinMode(MOTION_SENSOR, INPUT);
  pinMode(BUZZER, OUTPUT);
  digitalWrite(BUZZER, LOW);

  // SPIFFS
  spiFFSmounted = SPIFFS.begin();
  Serial.println(spiFFSmounted ? "‚úÖ SPIFFS mounted" : "‚ö†Ô∏è SPIFFS failed to mount");

  // WiFi
  connectWiFi();

  // Firebase config
  config.database_url = FIREBASE_HOST;
  config.api_key = FIREBASE_AUTH;
  Firebase.begin(&config, &auth);
  Firebase.reconnectWiFi(true);

  // NTP time (IST)
  configTime(19800, 0, "pool.ntp.org", "time.nist.gov");

  // Mark offline initially
  setOnlineFlag(false);

  Serial.println("Setup complete");
}

// ===== LOOP =====
void loop() {
  readGPS();
  getAlarmStatusFromFirebase();
  handleMotion();

  // Throttled status updates
  if (millis() - lastStatusWrite >= STATUS_UPDATE_MS) {
    updateVehicleStatus();   // writes /current and /components, pushes history if needed
    lastStatusWrite = millis();
  }

  // Heartbeat (rate-limited)
  if (millis() - lastHeartbeat >= HEARTBEAT_RATE_MS) {
    heartbeat();
  }

  // Try reconnecting WiFi if disconnected (non-blocking approach)
  if (WiFi.status() != WL_CONNECTED) {
    static unsigned long lastReconnectAttempt = 0;
    if (millis() - lastReconnectAttempt > 5000) {
      lastReconnectAttempt = millis();
      Serial.println("WiFi not connected - attempting reconnect...");
      WiFi.disconnect();
      WiFi.reconnect();
    }
  }

  delay(LOOP_DELAY_MS);
}

/* ===== helpers ===== */

void connectWiFi() {
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  Serial.print("Connecting to WiFi");
  int retry = 0;
  while (WiFi.status() != WL_CONNECTED && retry < 30) {
    delay(500);
    Serial.print(".");
    retry++;
  }
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úÖ WiFi Connected: " + WiFi.localIP().toString());
  } else {
    Serial.println("\n‚ùå WiFi Failed");
  }
}

void readGPS() {
  while (gpsSerial.available()) {
    gps.encode(gpsSerial.read());
    if (gps.location.isUpdated() && gps.location.isValid()) {
      latitude = gps.location.lat();
      longitude = gps.location.lng();
      lastLocationUpdate = millis();
      Serial.printf("üìç GPS: %.6f, %.6f\n", latitude, longitude);
    }
  }
}

void getAlarmStatusFromFirebase() {
  if (WiFi.status() != WL_CONNECTED) return;
  String path = "/users/" + String(USER_ID) + "/vehicle/alarm";
  if (Firebase.getString(fbdo, path)) {
    if (fbdo.dataType() == "string") {
      alarmState = fbdo.stringData();
      alarmState.toLowerCase();
    }
  } else {
    // non-fatal: just log
    Serial.println("FB get alarm failed: " + fbdo.errorReason());
  }
}

// Motion handler with debounce / stability check
void handleMotion() {
  int sensor = digitalRead(MOTION_SENSOR);
  unsigned long now = millis();

  if (sensor == HIGH) {
    if (motionRiseTime == 0) motionRiseTime = now;
    if (!motionDetected && (now - motionRiseTime) >= MOTION_STABLE_MS) {
      Serial.println("üö® Motion Detected (stable)");
      motionDetected = true;
      // trigger alarm only when conditions met
      if (alarmState == "on" && isStopped() && (now - lastTriggerTime > TRIGGER_COOLDOWN)) {
        triggerAlarm();
        lastTriggerTime = now;
      }
      lastMotion = now;
    }
  } else {
    motionRiseTime = 0;
    if (motionDetected) {
      Serial.println("Motion ended");
      motionDetected = false;
    }
  }
}

bool isStopped() {
  return (millis() - lastMotion > STOPPED_THRESHOLD);
}

void triggerAlarm() {
  Serial.println("üîî Trigger alarm");
  digitalWrite(BUZZER, HIGH);
  delay(700);
  digitalWrite(BUZZER, LOW);

  String loc = String(latitude, 6) + "," + String(longitude, 6);
  String t = getTimestamp();

  if (WiFi.status() == WL_CONNECTED) {
    String base = "/users/" + String(USER_ID) + "/vehicle/last_trigger";
    if (!Firebase.setString(fbdo, base + "/location", loc))
      Serial.println("FB set last_trigger location failed: " + fbdo.errorReason());
    if (!Firebase.setString(fbdo, base + "/time", t))
      Serial.println("FB set last_trigger time failed: " + fbdo.errorReason());
    if (!Firebase.setString(fbdo, base + "/status", "alert"))
      Serial.println("FB set last_trigger status failed: " + fbdo.errorReason());

    // push into history as well (rate-limited by HISTORY_PUSH_MS)
    if (millis() - lastHistoryPush >= HISTORY_PUSH_MS) {
      FirebaseJson h;
      h.set("location", loc);
      h.set("time", t);
      if (!Firebase.pushJSON(fbdo, "/users/" + String(USER_ID) + "/vehicle/history", h))
        Serial.println("FB push history failed: " + fbdo.errorReason());
      lastHistoryPush = millis();
    }
    Serial.println("‚úÖ Alarm logged to Firebase: " + loc + " @ " + t);
  } else {
    Serial.println("‚ö†Ô∏è Alarm event but no WiFi - saving offline");
    saveOfflineLog(loc, t);
  }
}

void updateVehicleStatus() {
  String status;
  if (latitude == 0.0 && longitude == 0.0) {
    status = "No GPS Signal";
  } else if (WiFi.status() != WL_CONNECTED) {
    status = "Offline";
  } else if (millis() - lastMotion < 10000) {
    status = "Moving";
  } else {
    status = "Stopped";
  }

  String locStr = String(latitude, 6) + "," + String(longitude, 6);
  String timeNow = getTimestamp();
  int batteryPercent = getBatteryLevel();

  // Prepare component health JSON
  FirebaseJson comp;
  comp.set("wifi", WiFi.status() == WL_CONNECTED ? "ok" : "down");
  comp.set("gps", (gps.location.isValid() && (millis() - lastLocationUpdate) < 60000) ? "ok" : "no_fix");
  comp.set("motion_sensor", motionDetected ? "activity" : "idle");
  comp.set("buzzer", "ok");

  if (WiFi.status() == WL_CONNECTED) {
    uploadOfflineLogs(); // try to upload saved logs

    String base = "/users/" + String(USER_ID) + "/vehicle";

    // Write current values (only when changed would be ideal; this writes every STATUS_UPDATE_MS)
    if (!Firebase.setFloat(fbdo, base + "/current/latitude", latitude))
      Serial.println("FB set lat failed: " + fbdo.errorReason());
    if (!Firebase.setFloat(fbdo, base + "/current/longitude", longitude))
      Serial.println("FB set lng failed: " + fbdo.errorReason());
    if (!Firebase.setString(fbdo, base + "/current/location", locStr))
      Serial.println("FB set location failed: " + fbdo.errorReason());
    if (!Firebase.setString(fbdo, base + "/current/last_active", timeNow))
      Serial.println("FB set last_active failed: " + fbdo.errorReason());
    if (!Firebase.setString(fbdo, base + "/current/status", status))
      Serial.println("FB set status failed: " + fbdo.errorReason());
    if (!Firebase.setInt(fbdo, base + "/current/battery", batteryPercent))
      Serial.println("FB set battery failed: " + fbdo.errorReason());

    // set components object
    if (!Firebase.setJSON(fbdo, base + "/components", comp))
      Serial.println("FB set components failed: " + fbdo.errorReason());

    // push history entry rate-limited (only when location or time changed sufficiently)
    if (millis() - lastHistoryPush >= HISTORY_PUSH_MS) {
      FirebaseJson history;
      history.set("location", locStr);
      history.set("time", timeNow);
      if (!Firebase.pushJSON(fbdo, base + "/history", history))
        Serial.println("FB push history failed: " + fbdo.errorReason());
      lastHistoryPush = millis();
    }

    // heartbeat/online update (rate-limited inside)
    setOnlineFlag(true);

    Serial.println("‚úÖ Updated Firebase: " + status + " | " + locStr);
  } else {
    // Save offline
    saveOfflineLog(locStr, timeNow);
    Serial.println("üì¶ Saved Offline");
  }
}

int getBatteryLevel() {
  // If you have a real voltage divider connected to A0, enable this block
#ifdef BATTERY_PIN
  int analogVal = analogRead(BATTERY_PIN);
  float voltage = analogVal * (3.3 / 1023.0) * 2.0; // adjust divider multiplier
  int percent = map((int)(voltage * 100), 330, 420, 0, 100);
  return constrain(percent, 0, 100);
#else
  // fallback: simulated stable value but varied by randomSeed
  return random(60, 96);
#endif
}

String getTimestamp() {
  time_t now = time(nullptr);
  struct tm* t = localtime(&now);
  char buffer[30];
  if (t) {
    sprintf(buffer, "%04d-%02d-%02d %02d:%02d:%02d",
            t->tm_year + 1900, t->tm_mon + 1,
            t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
    return String(buffer);
  } else {
    return String(millis());
  }
}

void saveOfflineLog(String location, String timeStr) {
  if (!spiFFSmounted) return;
  File file = SPIFFS.open("/offline.txt", "a+");
  if (file) {
    file.println(location + "," + timeStr);
    file.close();
  }
}

void uploadOfflineLogs() {
  if (!spiFFSmounted) return;
  if (!SPIFFS.exists("/offline.txt")) return;
  File file = SPIFFS.open("/offline.txt", "r");
  if (!file) return;

  while (file.available()) {
    String line = file.readStringUntil('\n');
    line.trim();
    if (line.length() == 0) continue;
    int lastComma = line.lastIndexOf(',');
    if (lastComma < 0) continue;
    String location = line.substring(0, lastComma);
    String timeStr = line.substring(lastComma + 1);

    FirebaseJson history;
    history.set("location", location);
    history.set("time", timeStr);
    if (!Firebase.pushJSON(fbdo, "/users/" + String(USER_ID) + "/vehicle/history", history)) {
      Serial.println("FB upload offline entry failed: " + fbdo.errorReason());
    }
    delay(100);
  }
  file.close();
  SPIFFS.remove("/offline.txt");
  Serial.println("‚òÅÔ∏è Offline logs uploaded");
}

// Rate-limited online flag setter: writes only on change or after ONLINE_TTL_MS
void setOnlineFlag(bool on) {
  String base = "/users/" + String(USER_ID) + "/vehicle";
  String t = getTimestamp();

  // write only if state changed OR TTL passed
  if (on != lastOnlineState || (millis() - lastHeartbeat) > ONLINE_TTL_MS) {
    if (on) {
      if (!Firebase.setBool(fbdo, base + "/online", true))
        Serial.println("FB set online failed: " + fbdo.errorReason());
      if (!Firebase.setString(fbdo, base + "/last_seen", t))
        Serial.println("FB set last_seen failed: " + fbdo.errorReason());
    } else {
      if (!Firebase.setBool(fbdo, base + "/online", false))
        Serial.println("FB set online false failed: " + fbdo.errorReason());
    }
    lastOnlineState = on;
    lastHeartbeat = millis();
  } else {
    // keep lastHeartbeat updated locally (avoid writing)
    lastHeartbeat = millis();
  }
}

void heartbeat() {
  if (WiFi.status() == WL_CONNECTED) {
    // only update on intervals inside setOnlineFlag()
    setOnlineFlag(true);
  } else {
    setOnlineFlag(false);
  }
}
